package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"time"

	graphql1 "github.com/peterbeamish/go-mcp-graphql/example/gqlgen-server/graphql"
	"github.com/peterbeamish/go-mcp-graphql/example/gqlgen-server/models"
)

// CreateEquipment is the resolver for the createEquipment field.
func (r *mutationResolver) CreateEquipment(ctx context.Context, input models.CreateEquipmentInput) (*models.Equipment, error) {
	// Find the facility
	facility := r.findFacilityByID(input.FacilityID)
	if facility == nil {
		return nil, fmt.Errorf("facility with ID %s not found", input.FacilityID)
	}

	// Create new equipment
	equipmentID := fmt.Sprintf("equipment-%d", len(r.equipment)+1)
	equipment := &models.Equipment{
		ID:           equipmentID,
		Name:         input.Name,
		Description:  input.Description,
		Manufacturer: input.Manufacturer,
		Model:        input.Model,
		SerialNumber: input.SerialNumber,
		Type:         input.Type,
		Status:       models.EquipmentStatusStopped, // Default status
		Facility:     facility,
		Specifications: &models.EquipmentSpecifications{
			PowerConsumption:          input.Specifications.PowerConsumption,
			MaxSpeed:                  input.Specifications.MaxSpeed,
			OperatingTemperature:      &models.TemperatureRange{Min: input.Specifications.OperatingTemperature.Min, Max: input.Specifications.OperatingTemperature.Max},
			Weight:                    input.Specifications.Weight,
			Dimensions:                &models.Dimensions{Length: input.Specifications.Dimensions.Length, Width: input.Specifications.Dimensions.Width, Height: input.Specifications.Dimensions.Height},
			ElectricalSpecs:           &models.ElectricalSpecs{Voltage: input.Specifications.ElectricalSpecs.Voltage, Current: input.Specifications.ElectricalSpecs.Current, PowerFactor: input.Specifications.ElectricalSpecs.PowerFactor, Frequency: input.Specifications.ElectricalSpecs.Frequency},
			EnvironmentalRequirements: input.Specifications.EnvironmentalRequirements,
			Certifications:            input.Specifications.Certifications,
		},
		InstalledAt:         input.InstalledAt,
		Efficiency:          100.0, // Default efficiency
		TotalOperatingHours: 0,     // New equipment starts at 0 hours
		MaintenanceRecords:  []*models.MaintenanceRecord{},
		Alerts:              []*models.EquipmentAlert{},
	}

	// Add to resolver
	r.equipment = append(r.equipment, equipment)

	// Add to facility equipment
	facility.Equipment = append(facility.Equipment, equipment)

	return equipment, nil
}

// UpdateEquipment is the resolver for the updateEquipment field.
func (r *mutationResolver) UpdateEquipment(ctx context.Context, id string, input models.UpdateEquipmentInput) (*models.Equipment, error) {
	// Find the equipment
	equipment := r.findEquipmentByID(id)
	if equipment == nil {
		return nil, fmt.Errorf("equipment with ID %s not found", id)
	}

	// Update fields if provided
	if input.Name != nil {
		equipment.Name = *input.Name
	}
	if input.Description != nil {
		equipment.Description = *input.Description
	}
	if input.Manufacturer != nil {
		equipment.Manufacturer = *input.Manufacturer
	}
	if input.Model != nil {
		equipment.Model = *input.Model
	}
	if input.SerialNumber != nil {
		equipment.SerialNumber = *input.SerialNumber
	}
	if input.Type != nil {
		equipment.Type = *input.Type
	}
	if input.InstalledAt != nil {
		equipment.InstalledAt = *input.InstalledAt
	}

	// Update facility if provided
	if input.FacilityID != nil {
		facility := r.findFacilityByID(*input.FacilityID)
		if facility == nil {
			return nil, fmt.Errorf("facility with ID %s not found", *input.FacilityID)
		}

		// Remove from old facility
		if equipment.Facility != nil {
			r.removeEquipmentFromFacility(equipment.Facility, equipment)
		}

		// Add to new facility
		equipment.Facility = facility
		facility.Equipment = append(facility.Equipment, equipment)
	}

	// Update specifications if provided
	if input.Specifications != nil {
		if equipment.Specifications == nil {
			equipment.Specifications = &models.EquipmentSpecifications{}
		}

		equipment.Specifications.PowerConsumption = input.Specifications.PowerConsumption
		equipment.Specifications.MaxSpeed = input.Specifications.MaxSpeed
		equipment.Specifications.Weight = input.Specifications.Weight

		if input.Specifications.OperatingTemperature != nil {
			equipment.Specifications.OperatingTemperature = &models.TemperatureRange{
				Min: input.Specifications.OperatingTemperature.Min,
				Max: input.Specifications.OperatingTemperature.Max,
			}
		}

		if input.Specifications.Dimensions != nil {
			equipment.Specifications.Dimensions = &models.Dimensions{
				Length: input.Specifications.Dimensions.Length,
				Width:  input.Specifications.Dimensions.Width,
				Height: input.Specifications.Dimensions.Height,
			}
		}

		if input.Specifications.ElectricalSpecs != nil {
			equipment.Specifications.ElectricalSpecs = &models.ElectricalSpecs{
				Voltage:     input.Specifications.ElectricalSpecs.Voltage,
				Current:     input.Specifications.ElectricalSpecs.Current,
				PowerFactor: input.Specifications.ElectricalSpecs.PowerFactor,
				Frequency:   input.Specifications.ElectricalSpecs.Frequency,
			}
		}

		equipment.Specifications.EnvironmentalRequirements = input.Specifications.EnvironmentalRequirements
		equipment.Specifications.Certifications = input.Specifications.Certifications
	}

	return equipment, nil
}

// DeleteEquipment is the resolver for the deleteEquipment field.
func (r *mutationResolver) DeleteEquipment(ctx context.Context, id string) (bool, error) {
	// Find the equipment
	equipment := r.findEquipmentByID(id)
	if equipment == nil {
		return false, fmt.Errorf("equipment with ID %s not found", id)
	}

	// Remove from facility
	if equipment.Facility != nil {
		r.removeEquipmentFromFacility(equipment.Facility, equipment)
	}

	// Remove from global equipment slice
	for i, e := range r.equipment {
		if e.ID == id {
			r.equipment = append(r.equipment[:i], r.equipment[i+1:]...)
			break
		}
	}

	// Remove related maintenance records
	r.removeMaintenanceRecordsForEquipment(id)

	// Remove related operational metrics
	r.removeOperationalMetricsForEquipment(id)

	// Remove related alerts
	r.removeAlertsForEquipment(id)

	return true, nil
}

// CreateFacility is the resolver for the createFacility field.
func (r *mutationResolver) CreateFacility(ctx context.Context, input models.CreateFacilityInput) (*models.Facility, error) {
	// Create new facility
	facilityID := fmt.Sprintf("facility-%d", len(r.facilities)+1)
	facility := &models.Facility{
		ID:               facilityID,
		Name:             input.Name,
		Address:          input.Address,
		Location:         &models.Location{Latitude: input.Location.Latitude, Longitude: input.Location.Longitude, Altitude: input.Location.Altitude},
		Capacity:         input.Capacity,
		Utilization:      0.0,                                         // New facility starts at 0% utilization
		Status:           models.FacilityOperationalStatusOperational, // Default status
		OperationalSince: input.OperationalSince,
		Manager:          input.Manager,
		ContactInfo: &models.ContactInfo{
			Phone:          input.ContactInfo.Phone,
			Email:          input.ContactInfo.Email,
			EmergencyPhone: input.ContactInfo.EmergencyPhone,
			ManagerContact: input.ContactInfo.ManagerContact,
		},
		Equipment: []*models.Equipment{},
		Personnel: []models.Personnel{},
	}

	// Add to resolver
	r.facilities = append(r.facilities, facility)

	return facility, nil
}

// UpdateFacility is the resolver for the updateFacility field.
func (r *mutationResolver) UpdateFacility(ctx context.Context, id string, input models.UpdateFacilityInput) (*models.Facility, error) {
	// Find the facility
	facility := r.findFacilityByID(id)
	if facility == nil {
		return nil, fmt.Errorf("facility with ID %s not found", id)
	}

	// Update fields if provided
	if input.Name != nil {
		facility.Name = *input.Name
	}
	if input.Address != nil {
		facility.Address = *input.Address
	}
	if input.Capacity != nil {
		facility.Capacity = *input.Capacity
	}
	if input.OperationalSince != nil {
		facility.OperationalSince = *input.OperationalSince
	}
	if input.Manager != nil {
		facility.Manager = *input.Manager
	}

	// Update location if provided
	if input.Location != nil {
		facility.Location = &models.Location{
			Latitude:  input.Location.Latitude,
			Longitude: input.Location.Longitude,
			Altitude:  input.Location.Altitude,
		}
	}

	// Update contact info if provided
	if input.ContactInfo != nil {
		if facility.ContactInfo == nil {
			facility.ContactInfo = &models.ContactInfo{}
		}
		facility.ContactInfo.Phone = input.ContactInfo.Phone
		facility.ContactInfo.Email = input.ContactInfo.Email
		facility.ContactInfo.EmergencyPhone = input.ContactInfo.EmergencyPhone
		facility.ContactInfo.ManagerContact = input.ContactInfo.ManagerContact
	}

	return facility, nil
}

// DeleteFacility is the resolver for the deleteFacility field.
func (r *mutationResolver) DeleteFacility(ctx context.Context, id string) (bool, error) {
	// Find the facility
	facility := r.findFacilityByID(id)
	if facility == nil {
		return false, fmt.Errorf("facility with ID %s not found", id)
	}

	// Remove all equipment from this facility
	for _, equipment := range facility.Equipment {
		// Remove from global equipment slice
		for i, e := range r.equipment {
			if e.ID == equipment.ID {
				r.equipment = append(r.equipment[:i], r.equipment[i+1:]...)
				break
			}
		}
	}

	// Remove all personnel from this facility
	for _, personnel := range facility.Personnel {
		// Remove from global personnel slice
		for i, p := range r.personnel {
			if p.GetID() == personnel.GetID() {
				r.personnel = append(r.personnel[:i], r.personnel[i+1:]...)
				break
			}
		}

		// Remove from specific type slices
		if manager, ok := personnel.(*models.Manager); ok {
			for i, m := range r.managers {
				if m.ID == manager.ID {
					r.managers = append(r.managers[:i], r.managers[i+1:]...)
					break
				}
			}
		} else if associate, ok := personnel.(*models.Associate); ok {
			for i, a := range r.associates {
				if a.ID == associate.ID {
					r.associates = append(r.associates[:i], r.associates[i+1:]...)
					break
				}
			}
		}
	}

	// Remove from global facilities slice
	for i, f := range r.facilities {
		if f.ID == id {
			r.facilities = append(r.facilities[:i], r.facilities[i+1:]...)
			break
		}
	}

	return true, nil
}

// ScheduleMaintenance is the resolver for the scheduleMaintenance field.
func (r *mutationResolver) ScheduleMaintenance(ctx context.Context, input models.ScheduleMaintenanceInput) (*models.MaintenanceRecord, error) {
	// Find the equipment
	equipment := r.findEquipmentByID(input.EquipmentID)
	if equipment == nil {
		return nil, fmt.Errorf("equipment with ID %s not found", input.EquipmentID)
	}

	// Create new maintenance record
	maintenanceID := fmt.Sprintf("maintenance-%d", len(r.maintenanceRecords)+1)
	maintenance := &models.MaintenanceRecord{
		ID:                 maintenanceID,
		Equipment:          equipment,
		Type:               input.Type,
		Priority:           input.Priority,
		ScheduledDate:      input.ScheduledDate,
		Status:             models.MaintenanceStatusScheduled,
		Description:        input.Description,
		AssignedTechnician: input.AssignedTechnician,
		EstimatedDuration:  input.EstimatedDuration,
		RequiredParts:      input.RequiredParts,
	}

	// Add to resolver
	r.maintenanceRecords = append(r.maintenanceRecords, maintenance)

	// Add to equipment maintenance records
	equipment.MaintenanceRecords = append(equipment.MaintenanceRecords, maintenance)

	return maintenance, nil
}

// UpdateMaintenanceRecord is the resolver for the updateMaintenanceRecord field.
func (r *mutationResolver) UpdateMaintenanceRecord(ctx context.Context, id string, input models.UpdateMaintenanceRecordInput) (*models.MaintenanceRecord, error) {
	// Find the maintenance record
	maintenance := r.findMaintenanceRecordByID(id)
	if maintenance == nil {
		return nil, fmt.Errorf("maintenance record with ID %s not found", id)
	}

	// Update fields if provided
	if input.Type != nil {
		maintenance.Type = *input.Type
	}
	if input.Priority != nil {
		maintenance.Priority = *input.Priority
	}
	if input.ScheduledDate != nil {
		maintenance.ScheduledDate = *input.ScheduledDate
	}
	if input.Description != nil {
		maintenance.Description = *input.Description
	}
	if input.AssignedTechnician != nil {
		maintenance.AssignedTechnician = *input.AssignedTechnician
	}
	if input.EstimatedDuration != nil {
		maintenance.EstimatedDuration = *input.EstimatedDuration
	}
	if input.RequiredParts != nil {
		maintenance.RequiredParts = input.RequiredParts
	}
	if input.Status != nil {
		maintenance.Status = *input.Status
	}

	return maintenance, nil
}

// CompleteMaintenance is the resolver for the completeMaintenance field.
func (r *mutationResolver) CompleteMaintenance(ctx context.Context, id string, input models.CompleteMaintenanceInput) (*models.MaintenanceRecord, error) {
	// Find the maintenance record
	maintenance := r.findMaintenanceRecordByID(id)
	if maintenance == nil {
		return nil, fmt.Errorf("maintenance record with ID %s not found", id)
	}

	// Update maintenance record with completion details
	maintenance.Status = models.MaintenanceStatusCompleted
	maintenance.CompletedDate = &input.CompletedDate
	maintenance.ActualDuration = &input.ActualDuration
	maintenance.Cost = input.Cost
	maintenance.Notes = input.Notes

	// Update equipment's last maintenance date
	maintenance.Equipment.LastMaintenanceAt = &input.CompletedDate

	// Calculate next maintenance date (simplified: 3 months from completion)
	nextMaintenanceDate := time.Now().AddDate(0, 3, 0).Format("2006-01-02")
	maintenance.Equipment.NextMaintenanceAt = &nextMaintenanceDate

	return maintenance, nil
}

// RecordOperationalMetric is the resolver for the recordOperationalMetric field.
func (r *mutationResolver) RecordOperationalMetric(ctx context.Context, input models.RecordOperationalMetricInput) (*models.OperationalMetric, error) {
	// Find the equipment
	equipment := r.findEquipmentByID(input.EquipmentID)
	if equipment == nil {
		return nil, fmt.Errorf("equipment with ID %s not found", input.EquipmentID)
	}

	// Create new operational metric
	metricID := fmt.Sprintf("metric-%d", len(r.operationalMetrics)+1)
	meetsTarget := true
	if input.TargetValue != nil {
		meetsTarget = input.Value <= *input.TargetValue
	}

	metric := &models.OperationalMetric{
		ID:          metricID,
		Equipment:   equipment,
		MetricType:  input.MetricType,
		Value:       input.Value,
		Unit:        input.Unit,
		RecordedAt:  time.Now().Format(time.RFC3339),
		TargetValue: input.TargetValue,
		MeetsTarget: meetsTarget,
		Notes:       input.Notes,
	}

	// Add to resolver
	r.operationalMetrics = append(r.operationalMetrics, metric)

	return metric, nil
}

// UpdateEquipmentStatus is the resolver for the updateEquipmentStatus field.
func (r *mutationResolver) UpdateEquipmentStatus(ctx context.Context, id string, status models.EquipmentStatus, notes *string) (*models.Equipment, error) {
	// Find the equipment
	equipment := r.findEquipmentByID(id)
	if equipment == nil {
		return nil, fmt.Errorf("equipment with ID %s not found", id)
	}

	// Update status
	equipment.Status = status

	// If notes are provided, create an alert
	if notes != nil && *notes != "" {
		alertID := fmt.Sprintf("alert-%d", len(r.alerts)+1)
		alert := &models.EquipmentAlert{
			ID:           alertID,
			Equipment:    equipment,
			Type:         models.AlertTypeEquipmentFault,
			Severity:     models.AlertSeverityInfo,
			Description:  *notes,
			GeneratedAt:  time.Now().Format(time.RFC3339),
			Acknowledged: false,
			Resolved:     false,
		}
		r.alerts = append(r.alerts, alert)
		equipment.Alerts = append(equipment.Alerts, alert)
	}

	return equipment, nil
}

// AddManagerToFacility is the resolver for the addManagerToFacility field.
func (r *mutationResolver) AddManagerToFacility(ctx context.Context, facilityID string, input models.AddManagerInput) (*models.Manager, error) {
	// Find the facility
	var facility *models.Facility
	for _, f := range r.facilities {
		if f.ID == facilityID {
			facility = f
			break
		}
	}
	if facility == nil {
		return nil, fmt.Errorf("facility with ID %s not found", facilityID)
	}

	// Create new manager
	managerID := fmt.Sprintf("manager-%d", len(r.managers)+1)
	manager := &models.Manager{
		ID:            managerID,
		Name:          input.Name,
		Email:         input.Email,
		Phone:         input.Phone,
		JoinedAt:      input.JoinedAt,
		Status:        models.PersonnelStatusActive,
		Department:    input.Department,
		DirectReports: 0,
		Level:         input.Level,
	}

	// Add to resolver
	r.managers = append(r.managers, manager)
	r.personnel = append(r.personnel, manager)

	// Add to facility personnel
	facility.Personnel = append(facility.Personnel, manager)

	return manager, nil
}

// AddAssociateToFacility is the resolver for the addAssociateToFacility field.
func (r *mutationResolver) AddAssociateToFacility(ctx context.Context, facilityID string, input models.AddAssociateInput) (*models.Associate, error) {
	// Find the facility
	var facility *models.Facility
	for _, f := range r.facilities {
		if f.ID == facilityID {
			facility = f
			break
		}
	}
	if facility == nil {
		return nil, fmt.Errorf("facility with ID %s not found", facilityID)
	}

	// Find the manager if reportsToId is provided
	var reportsTo *models.Manager
	if input.ReportsToID != nil {
		for _, m := range r.managers {
			if m.ID == *input.ReportsToID {
				reportsTo = m
				break
			}
		}
		if reportsTo == nil {
			return nil, fmt.Errorf("manager with ID %s not found", *input.ReportsToID)
		}
	}

	// Create new associate
	associateID := fmt.Sprintf("associate-%d", len(r.associates)+1)
	associate := &models.Associate{
		ID:         associateID,
		Name:       input.Name,
		Email:      input.Email,
		Phone:      input.Phone,
		JoinedAt:   input.JoinedAt,
		Status:     models.PersonnelStatusActive,
		JobTitle:   input.JobTitle,
		Department: input.Department,
		ReportsTo:  reportsTo,
	}

	// Add to resolver
	r.associates = append(r.associates, associate)
	r.personnel = append(r.personnel, associate)

	// Add to facility personnel
	facility.Personnel = append(facility.Personnel, associate)

	// Update manager's direct reports count if reportsTo is specified
	if reportsTo != nil {
		reportsTo.DirectReports++
	}

	return associate, nil
}

// RemovePersonnelFromFacility is the resolver for the removePersonnelFromFacility field.
func (r *mutationResolver) RemovePersonnelFromFacility(ctx context.Context, facilityID string, personnelID string) (bool, error) {
	// Find the facility
	var facility *models.Facility
	for _, f := range r.facilities {
		if f.ID == facilityID {
			facility = f
			break
		}
	}
	if facility == nil {
		return false, fmt.Errorf("facility with ID %s not found", facilityID)
	}

	// Find and remove personnel from facility
	for i, p := range facility.Personnel {
		if p.GetID() == personnelID {
			// Remove from facility personnel
			facility.Personnel = append(facility.Personnel[:i], facility.Personnel[i+1:]...)

			// If it's an associate, update manager's direct reports count
			if associate, ok := p.(*models.Associate); ok && associate.ReportsTo != nil {
				associate.ReportsTo.DirectReports--
			}

			// Remove from global personnel slice
			for j, globalP := range r.personnel {
				if globalP.GetID() == personnelID {
					r.personnel = append(r.personnel[:j], r.personnel[j+1:]...)
					break
				}
			}

			// Remove from specific type slices
			if manager, ok := p.(*models.Manager); ok {
				for j, m := range r.managers {
					if m.ID == manager.ID {
						r.managers = append(r.managers[:j], r.managers[j+1:]...)
						break
					}
				}
			} else if associate, ok := p.(*models.Associate); ok {
				for j, a := range r.associates {
					if a.ID == associate.ID {
						r.associates = append(r.associates[:j], r.associates[j+1:]...)
						break
					}
				}
			}

			return true, nil
		}
	}

	return false, fmt.Errorf("personnel with ID %s not found in facility %s", personnelID, facilityID)
}

// Equipment is the resolver for the equipment field.
func (r *queryResolver) Equipment(ctx context.Context) ([]*models.Equipment, error) {
	return r.equipment, nil
}

// EquipmentByID is the resolver for the equipmentById field.
func (r *queryResolver) EquipmentByID(ctx context.Context, id string) (*models.Equipment, error) {
	equipment := r.findEquipmentByID(id)
	if equipment == nil {
		return nil, fmt.Errorf("equipment with ID %s not found", id)
	}
	return equipment, nil
}

// Facilities is the resolver for the facilities field.
func (r *queryResolver) Facilities(ctx context.Context) ([]*models.Facility, error) {
	return r.facilities, nil
}

// FacilityByID is the resolver for the facilityById field.
func (r *queryResolver) FacilityByID(ctx context.Context, id string) (*models.Facility, error) {
	facility := r.findFacilityByID(id)
	if facility == nil {
		return nil, fmt.Errorf("facility with ID %s not found", id)
	}
	return facility, nil
}

// MaintenanceRecords is the resolver for the maintenanceRecords field.
func (r *queryResolver) MaintenanceRecords(ctx context.Context) ([]*models.MaintenanceRecord, error) {
	return r.maintenanceRecords, nil
}

// MaintenanceRecordsByEquipment is the resolver for the maintenanceRecordsByEquipment field.
func (r *queryResolver) MaintenanceRecordsByEquipment(ctx context.Context, equipmentID string) ([]*models.MaintenanceRecord, error) {
	// Find the equipment
	equipment := r.findEquipmentByID(equipmentID)
	if equipment == nil {
		return nil, fmt.Errorf("equipment with ID %s not found", equipmentID)
	}
	return equipment.MaintenanceRecords, nil
}

// OperationalMetrics is the resolver for the operationalMetrics field.
func (r *queryResolver) OperationalMetrics(ctx context.Context) ([]*models.OperationalMetric, error) {
	return r.operationalMetrics, nil
}

// FacilityStatus is the resolver for the facilityStatus field.
func (r *queryResolver) FacilityStatus(ctx context.Context, facilityID string) (*models.FacilityStatus, error) {
	// Find the facility
	facility := r.findFacilityByID(facilityID)
	if facility == nil {
		return nil, fmt.Errorf("facility with ID %s not found", facilityID)
	}

	// Calculate real-time status
	equipmentRunning := 0
	equipmentStopped := 0
	equipmentInMaintenance := 0
	activeAlerts := 0
	totalEfficiency := 0.0
	equipmentCount := 0

	for _, equipment := range facility.Equipment {
		equipmentCount++
		totalEfficiency += equipment.Efficiency

		switch equipment.Status {
		case models.EquipmentStatusRunning:
			equipmentRunning++
		case models.EquipmentStatusStopped:
			equipmentStopped++
		case models.EquipmentStatusMaintenance:
			equipmentInMaintenance++
		}

		// Count active alerts
		for _, alert := range equipment.Alerts {
			if !alert.Resolved {
				activeAlerts++
			}
		}
	}

	// Calculate average efficiency
	avgEfficiency := 0.0
	if equipmentCount > 0 {
		avgEfficiency = totalEfficiency / float64(equipmentCount)
	}

	// Calculate production rate (simplified: based on running equipment)
	productionRate := float64(equipmentRunning) * 10.0 // 10 units per hour per running equipment

	status := &models.FacilityStatus{
		Facility:               facility,
		Status:                 facility.Status,
		EquipmentRunning:       equipmentRunning,
		EquipmentStopped:       equipmentStopped,
		EquipmentInMaintenance: equipmentInMaintenance,
		ActiveAlerts:           activeAlerts,
		ProductionRate:         productionRate,
		Efficiency:             avgEfficiency,
		LastUpdated:            time.Now().Format(time.RFC3339),
	}

	return status, nil
}

// Personnel is the resolver for the personnel field.
func (r *queryResolver) Personnel(ctx context.Context) ([]models.Personnel, error) {
	// Return all personnel across all facilities
	return r.personnel, nil
}

// EquipmentNotifications is the resolver for the equipmentNotifications field.
func (r *queryResolver) EquipmentNotifications(ctx context.Context) ([]models.EquipmentNotification, error) {
	notifications := r.GetEquipmentNotifications()
	return notifications, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
